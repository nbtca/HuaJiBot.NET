using System.Diagnostics.CodeAnalysis;

namespace HuaJiBot.NET.Plugin;

/// <summary>
/// Generated fast plugin configuration access to replace reflection
/// This demonstrates what a source generator would produce
/// </summary>
public static class PluginConfigAccessor
{
    private static readonly Dictionary<Type, Func<object, ConfigBase?>> _configAccessors = new()
    {
        // These would be generated by source generator for each plugin
        // For demonstration, we'll populate this at runtime or via initialization
        // [typeof(SomePluginType)] = plugin => ((SomePluginType)plugin).Config,
    };

    /// <summary>
    /// Fast plugin config access that replaces the reflection-based TryGetPluginConfig
    /// </summary>
    public static bool TryGetPluginConfigFast(
        object plugin,
        [NotNullWhen(true)] out ConfigBase? config
    )
    {
        var pluginType = plugin.GetType();

        if (_configAccessors.TryGetValue(pluginType, out var accessor))
        {
            config = accessor(plugin);
            return config != null;
        }

        // Fallback to reflection for unknown plugins
        return TryGetPluginConfigReflection(plugin, out config);
    }

    /// <summary>
    /// Original reflection-based implementation as fallback
    /// </summary>
    private static bool TryGetPluginConfigReflection(
        object plugin,
        [NotNullWhen(true)] out ConfigBase? config
    )
    {
        foreach (var interfaceType in plugin.GetType().GetInterfaces())
        {
            foreach (var property in interfaceType.GetProperties())
            {
                if (property.PropertyType.IsAssignableTo(typeof(ConfigBase)))
                {
                    config = property.GetValue(plugin) as ConfigBase;
                    if (config != null)
                    {
                        return true;
                    }
                }
            }
        }
        config = null;
        return false;
    }

    /// <summary>
    /// Register a new plugin type (would be called by generated code)
    /// </summary>
    public static void RegisterPlugin<TPlugin, TConfig>(Func<TPlugin, TConfig> accessor)
        where TPlugin : class
        where TConfig : ConfigBase
    {
        _configAccessors[typeof(TPlugin)] = plugin => accessor((TPlugin)plugin);
    }
}
