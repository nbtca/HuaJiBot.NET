using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace HuaJiBot.NET.SourceGenerator;

[Generator]
public class CommandSourceGenerator : IIncrementalGenerator
{
    private const string CommandAttributeFullName = "HuaJiBot.NET.Commands.CommandAttribute";
    private const string PluginBaseFullName = "HuaJiBot.NET.PluginBase";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all classes that inherit from PluginBase
        var pluginClasses = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => s is ClassDeclarationSyntax { BaseList: not null },
                transform: static (ctx, _) => GetPluginClass(ctx))
            .Where(static m => m is not null)!;

        // Combine and generate
        context.RegisterSourceOutput(pluginClasses.Collect(), static (spc, source) => Execute(source.Where(s => s != null)!, spc));
    }

    private static ClassDeclarationSyntax? GetPluginClass(GeneratorSyntaxContext context)
    {
        var classDecl = (ClassDeclarationSyntax)context.Node;
        
        // Check if this class inherits from PluginBase
        var semanticModel = context.SemanticModel;
        var classSymbol = semanticModel.GetDeclaredSymbol(classDecl);
        
        if (classSymbol == null) return null;
        
        // Check inheritance chain
        var baseType = classSymbol.BaseType;
        while (baseType != null)
        {
            if (baseType.ToDisplayString() == PluginBaseFullName)
            {
                return classDecl;
            }
            baseType = baseType.BaseType;
        }
        
        return null;
    }

    private static void Execute(IEnumerable<ClassDeclarationSyntax> pluginClasses, SourceProductionContext context)
    {
        if (!pluginClasses.Any()) return;

        var stringBuilder = new StringBuilder();

        foreach (var pluginClass in pluginClasses)
        {
            GenerateCommandsForPlugin(pluginClass, stringBuilder, context);
        }
    }

    private static void GenerateCommandsForPlugin(ClassDeclarationSyntax pluginClass, StringBuilder sb, SourceProductionContext context)
    {
        var className = pluginClass.Identifier.ValueText;
        var namespaceName = GetNamespace(pluginClass);
        
        // Find all methods with CommandAttribute
        var commandMethods = pluginClass.Members
            .OfType<MethodDeclarationSyntax>()
            .Where(m => m.AttributeLists.Any(al => 
                al.Attributes.Any(a => 
                    IsCommandAttribute(a))))
            .ToList();

        if (!commandMethods.Any()) return;

        sb.Clear();
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using System.Text.RegularExpressions;");
        sb.AppendLine("using HuaJiBot.NET.Commands;");
        sb.AppendLine("using HuaJiBot.NET.Events;");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(namespaceName))
        {
            sb.AppendLine($"namespace {namespaceName};");
            sb.AppendLine();
        }

        sb.AppendLine($"partial class {className}");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Generated command information for fast command lookup");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public override IEnumerable<CommandInfo> GetAllCommands()");
        sb.AppendLine("    {");

        foreach (var method in commandMethods)
        {
            GenerateCommandInfo(method, sb);
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        var fileName = $"{className}_Commands.g.cs";
        context.AddSource(fileName, SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static void GenerateCommandInfo(MethodDeclarationSyntax method, StringBuilder sb)
    {
        var methodName = method.Identifier.ValueText;
        
        // Extract command attribute values
        var commandAttr = method.AttributeLists
            .SelectMany(al => al.Attributes)
            .FirstOrDefault(a => IsCommandAttribute(a));

        if (commandAttr?.ArgumentList?.Arguments.Count >= 2)
        {
            var keyArg = commandAttr.ArgumentList.Arguments[0];
            var descArg = commandAttr.ArgumentList.Arguments[1];
            
            var key = GetStringLiteralValue(keyArg.Expression);
            var description = GetStringLiteralValue(descArg.Expression);

            sb.AppendLine($"        yield return new CommandInfo(");
            sb.AppendLine($"            \"{key}\",");
            sb.AppendLine($"            \"{description}\",");
            sb.AppendLine($"            args => ");
            sb.AppendLine($"            {{");
            
            // Check if method returns void
            var isVoid = method.ReturnType?.ToString() == "void" || method.ReturnType == null;
            
            if (isVoid)
            {
                sb.AppendLine($"                {methodName}(");
            }
            else
            {
                sb.AppendLine($"                var result = {methodName}(");
            }
            
            // Generate parameter passing
            var parameters = method.ParameterList.Parameters;
            for (int i = 0; i < parameters.Count; i++)
            {
                var param = parameters[i];
                var paramType = param.Type?.ToString() ?? "object";
                var typeForCast = paramType.TrimEnd('?');
                
                if (i > 0) sb.Append(", ");
                
                if (paramType.EndsWith("?"))
                {
                    // Nullable type
                    sb.Append($"args != null && args.Length > {i} && args[{i}] != null ? ({typeForCast})args[{i}]! : ({paramType})null");
                }
                else
                {
                    sb.Append($"args != null && args.Length > {i} ? ({paramType})args[{i}]! : default({paramType})");
                }
            }
            
            sb.AppendLine(");");
            
            if (!isVoid)
            {
                sb.AppendLine($"                if (result is Task task)");
                sb.AppendLine($"                {{");
                sb.AppendLine($"                    task.ContinueWith(");
                sb.AppendLine($"                        t =>");
                sb.AppendLine($"                        {{");
                sb.AppendLine($"                            if (t.Exception is not null)");
                sb.AppendLine($"                            {{");
                sb.AppendLine($"                                Error($\"执行命令 {key} 时出现异常：\", t.Exception);");
                sb.AppendLine($"                            }}");
                sb.AppendLine($"                        }},");
                sb.AppendLine($"                        TaskContinuationOptions.OnlyOnFaulted");
                sb.AppendLine($"                    );");
                sb.AppendLine($"                }}");
            }
            sb.AppendLine($"            }},");
            
            // Generate argument info
            sb.AppendLine($"            new CommandArgumentInfo[]");
            sb.AppendLine($"            {{");
            
            foreach (var param in parameters)
            {
                GenerateArgumentInfo(param, sb);
            }
            
            sb.AppendLine($"            }}");
            sb.AppendLine($"        );");
            sb.AppendLine();
        }
    }

    private static void GenerateArgumentInfo(ParameterSyntax param, StringBuilder sb)
    {
        var paramType = param.Type?.ToString() ?? "object";
        
        // Handle nullable types by removing the ? for typeof
        var typeForTypeof = paramType.TrimEnd('?');
        
        var isOptional = param.Default != null ? "true" : "false";
        var defaultValue = param.Default?.Value.ToString() ?? "null";
        
        // Find command argument attribute
        var argAttr = param.AttributeLists
            .SelectMany(al => al.Attributes)
            .FirstOrDefault(a => IsCommandArgumentAttribute(a));

        string attributeCreation;
        if (argAttr != null)
        {
            attributeCreation = GenerateCommandArgumentAttribute(argAttr, typeForTypeof);
        }
        else
        {
            // If no attribute found, use CommandArgumentUnknownAttribute as fallback
            attributeCreation = $"new CommandArgumentUnknownAttribute(typeof({typeForTypeof}))";
        }

        sb.AppendLine($"                new CommandArgumentInfo(");
        sb.AppendLine($"                    {attributeCreation},");
        sb.AppendLine($"                    typeof({typeForTypeof}),");
        sb.AppendLine($"                    {isOptional},");
        sb.AppendLine($"                    {defaultValue}");
        sb.AppendLine($"                ),");
    }

    private static string GenerateCommandArgumentAttribute(AttributeSyntax attribute, string typeForTypeof)
    {
        var name = attribute.Name.ToString();
        
        // Handle CommandArgumentString
        if (name == "CommandArgumentString" || name == "CommandArgumentStringAttribute" || name.EndsWith(".CommandArgumentStringAttribute"))
        {
            var description = GetAttributeArgument(attribute, 0) ?? "\"\"";
            return $"new CommandArgumentStringAttribute({description})";
        }
        
        // Handle CommandArgumentStringMatch
        if (name == "CommandArgumentStringMatch" || name == "CommandArgumentStringMatchAttribute" || name.EndsWith(".CommandArgumentStringMatchAttribute"))
        {
            var pattern = GetAttributeArgument(attribute, 0) ?? "\".*\"";
            var options = GetAttributeArgument(attribute, 1) ?? "RegexOptions.None";
            var description = GetAttributeArgument(attribute, 2) ?? "\"\"";
            return $"new CommandArgumentStringMatchAttribute({pattern}, {options}, {description})";
        }
        
        // Handle CommandArgumentEnum
        if (name == "CommandArgumentEnum" || name == "CommandArgumentEnumAttribute" || name.EndsWith(".CommandArgumentEnumAttribute"))
        {
            var description = GetAttributeArgument(attribute, 0) ?? "\"\"";
            // For generic enum attributes, we need to preserve the type parameter
            if (attribute.Name is GenericNameSyntax genericName)
            {
                var typeArg = genericName.TypeArgumentList.Arguments.FirstOrDefault()?.ToString() ?? typeForTypeof;
                return $"new CommandArgumentEnumAttribute<{typeArg}>({description})";
            }
            return $"new CommandArgumentEnumAttribute<{typeForTypeof}>({description})";
        }
        
        // Fallback to CommandArgumentUnknownAttribute
        return $"new CommandArgumentUnknownAttribute(typeof({typeForTypeof}))";
    }

    private static string? GetAttributeArgument(AttributeSyntax attribute, int index)
    {
        if (attribute.ArgumentList?.Arguments.Count > index)
        {
            var arg = attribute.ArgumentList.Arguments[index];
            return arg.Expression.ToString();
        }
        return null;
    }

    private static bool IsCommandArgumentAttribute(AttributeSyntax attribute)
    {
        var name = attribute.Name.ToString();
        return name.Contains("CommandArgument") && 
               !name.Contains("CommandArgumentUnknown");
    }

    private static string GetStringLiteralValue(ExpressionSyntax expression)
    {
        if (expression is LiteralExpressionSyntax literal &&
            literal.Token.IsKind(SyntaxKind.StringLiteralToken))
        {
            return literal.Token.ValueText;
        }
        return expression.ToString().Trim('"');
    }

    private static bool IsCommandAttribute(AttributeSyntax attribute)
    {
        var name = attribute.Name.ToString();
        return name == "Command" || name == "CommandAttribute" || name.EndsWith(".CommandAttribute");
    }

    private static string GetNamespace(ClassDeclarationSyntax classDecl)
    {
        var namespaceDecl = classDecl.Ancestors().OfType<NamespaceDeclarationSyntax>().FirstOrDefault();
        if (namespaceDecl != null)
        {
            return namespaceDecl.Name.ToString();
        }

        var fileScopedNamespace = classDecl.Ancestors().OfType<FileScopedNamespaceDeclarationSyntax>().FirstOrDefault();
        if (fileScopedNamespace != null)
        {
            return fileScopedNamespace.Name.ToString();
        }

        return string.Empty;
    }
}