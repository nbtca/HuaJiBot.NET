using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace HuaJiBot.NET.SourceGenerator;

[Generator]
public class CommandSourceGenerator : IIncrementalGenerator
{
    private const string CommandAttributeFullName = "HuaJiBot.NET.Commands.CommandAttribute";
    private const string CommandArgumentAttributeBaseFullName =
        "HuaJiBot.NET.Commands.CommandArgumentAttribute";
    private const string PluginBaseFullName = "HuaJiBot.NET.PluginBase";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all classes that inherit from PluginBase and capture the SemanticModel
        var pluginClasses = context
            .SyntaxProvider.CreateSyntaxProvider(
                predicate: static (s, _) => s is ClassDeclarationSyntax { BaseList: not null },
                transform: static (ctx, _) => GetPluginClassWithModel(ctx)
            )
            .Where(static m => m.classDecl is not null)!;

        // Combine and generate
        context.RegisterSourceOutput(
            pluginClasses.Collect(),
            static (spc, source) => Execute(source.Where(s => s.classDecl != null)!, spc)
        );
    }

    // Return a tuple with the class syntax and its SemanticModel
    private static (
        ClassDeclarationSyntax? classDecl,
        SemanticModel? semanticModel
    ) GetPluginClassWithModel(GeneratorSyntaxContext context)
    {
        var classDecl = (ClassDeclarationSyntax)context.Node;

        // Check if this class inherits from PluginBase
        var semanticModel = context.SemanticModel;
        var classSymbol = semanticModel.GetDeclaredSymbol(classDecl);

        if (classSymbol == null)
            return (null, null);

        // Check inheritance chain
        var baseType = classSymbol.BaseType;
        while (baseType != null)
        {
            if (baseType.ToDisplayString() == PluginBaseFullName)
            {
                return (classDecl, semanticModel);
            }
            baseType = baseType.BaseType;
        }

        return (null, null);
    }

    private static void Execute(
        IEnumerable<(ClassDeclarationSyntax classDecl, SemanticModel semanticModel)> pluginClasses,
        SourceProductionContext context
    )
    {
        if (!pluginClasses.Any())
            return;

        var stringBuilder = new StringBuilder();

        foreach (var (pluginClass, semanticModel) in pluginClasses)
        {
            GenerateCommandsForPlugin(pluginClass, stringBuilder, context, semanticModel);
        }
    }

    private static void GenerateCommandsForPlugin(
        ClassDeclarationSyntax pluginClass,
        StringBuilder sb,
        SourceProductionContext context,
        SemanticModel semanticModel
    )
    {
        sb.Clear();
        var className = pluginClass.Identifier.ValueText;
        var namespaceName = GetNamespace(pluginClass);

        // Find all methods with CommandAttribute
        var commandMethods = pluginClass
            .Members.OfType<MethodDeclarationSyntax>()
            .Where(m =>
                m.AttributeLists.Any(al =>
                    al.Attributes.Any(a => IsCommandAttribute(a, semanticModel))
                )
            )
            .ToArray();

        if (!commandMethods.Any())
            return;

        sb.AppendLine("// <auto-generated />");

        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using System.Text.RegularExpressions;");
        sb.AppendLine("using HuaJiBot.NET.Commands;");
        sb.AppendLine("using HuaJiBot.NET.Events;");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(namespaceName))
        {
            sb.AppendLine($"namespace {namespaceName};");
            sb.AppendLine();
        }

        sb.AppendLine($"partial class {className}");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Generated command information for fast command lookup");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public override IEnumerable<CommandInfo> GetAllCommands()");
        sb.AppendLine("    {");

        foreach (var method in commandMethods)
        {
            GenerateCommandInfo(method, sb, semanticModel);
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        var fileName = $"{className}_Commands.g.cs";
        //var codeFmt = CSharpier.Core.CSharp.CSharpFormatter.Format(sb.ToString());
        //if (codeFmt.CompilationErrors.Any())
        //{
        //    foreach (var codeFmtCompilationError in codeFmt.CompilationErrors)
        //    {
        //        context.ReportDiagnostic(codeFmtCompilationError);
        //    }
        //}
        //else
        //{
        //    sb.Clear();
        //    sb.Append(codeFmt.Code);
        //}
        context.AddSource(fileName, SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static void GenerateCommandInfo(
        MethodDeclarationSyntax method,
        StringBuilder sb,
        SemanticModel semanticModel
    )
    {
        var methodName = method.Identifier.ValueText;

        // Extract command attribute values
        var commandAttr = method
            .AttributeLists.SelectMany(al => al.Attributes)
            .FirstOrDefault(a => IsCommandAttribute(a, semanticModel));

        if (commandAttr?.ArgumentList?.Arguments.Count >= 2)
        {
            var keyArg = commandAttr.ArgumentList.Arguments[0];
            var descArg = commandAttr.ArgumentList.Arguments[1];

            var key = GetStringLiteralValue(keyArg.Expression);
            var description = GetStringLiteralValue(descArg.Expression);

            sb.AppendLine($"        yield return new CommandInfo(");
            sb.AppendLine($"            \"{key}\",");
            sb.AppendLine($"            \"{description}\",");
            sb.AppendLine($"            args => ");
            sb.AppendLine($"            {{");

            // Check if method returns void
            var isVoid = method.ReturnType?.ToString() == "void" || method.ReturnType == null;

            if (isVoid)
            {
                sb.AppendLine($"                {methodName}(");
            }
            else
            {
                sb.AppendLine($"                var result = {methodName}(");
            }

            // Generate parameter passing
            var parameters = method.ParameterList.Parameters;
            for (int i = 0; i < parameters.Count; i++)
            {
                var param = parameters[i];
                var paramType = GetFullTypeName(param.Type, semanticModel);
                var typeForCast = paramType.TrimEnd('?');

                if (i > 0)
                    sb.Append(", ");

                if (paramType.EndsWith("?"))
                {
                    // Nullable type
                    sb.Append(
                        $"args != null && args.Length > {i} && args[{i}] != null ? ({typeForCast})args[{i}]! : ({paramType})null"
                    );
                }
                else
                {
                    sb.Append(
                        $"args != null && args.Length > {i} ? ({paramType})args[{i}]! : default({paramType})"
                    );
                }
            }

            sb.AppendLine(");");

            if (!isVoid)
            {
                sb.AppendLine($"                if (result is Task task)");
                sb.AppendLine($"                {{");
                sb.AppendLine($"                    task.ContinueWith(");
                sb.AppendLine($"                        t =>");
                sb.AppendLine($"                        {{");
                sb.AppendLine($"                            if (t.Exception is not null)");
                sb.AppendLine($"                            {{");
                sb.AppendLine(
                    $"                                Error($\"执行命令 {key} 时出现异常：\", t.Exception);"
                );
                sb.AppendLine($"                            }}");
                sb.AppendLine($"                        }},");
                sb.AppendLine($"                        TaskContinuationOptions.OnlyOnFaulted");
                sb.AppendLine($"                    );");
                sb.AppendLine($"                }}");
            }
            sb.AppendLine($"            }},");

            // Generate argument info
            sb.AppendLine($"            new CommandArgumentInfo[]");
            sb.AppendLine($"            {{");

            foreach (var param in parameters)
            {
                GenerateArgumentInfo(param, semanticModel, sb);
            }

            sb.AppendLine($"            }}");
            sb.AppendLine($"        );");
            sb.AppendLine();
        }
    }

    private static string GetFullTypeName(
        TypeSyntax? type,
        SemanticModel semanticModel,
        string defaultType = "object"
    )
    {
        if (type != null)
        {
            var typeInfo = semanticModel.GetTypeInfo(type);
            return typeInfo.Type?.ToDisplayString() ?? type.ToString();
        }
        return defaultType;
    }

    private static void GenerateArgumentInfo(
        ParameterSyntax param,
        SemanticModel semanticModel,
        StringBuilder sb
    )
    {
        var paramType = GetFullTypeName(param.Type, semanticModel);

        // Handle nullable types by removing the ? for typeof
        var typeForTypeof = paramType.TrimEnd('?');

        var isOptional = param.Default != null ? "true" : "false";
        var defaultValue = param.Default?.Value.ToString() ?? "null";

        // Find command argument attribute
        var argAttr = param
            .AttributeLists.SelectMany(al => al.Attributes)
            .FirstOrDefault(attr => IsCommandArgumentAttribute(semanticModel, attr));

        string attributeCreation;
        if (argAttr != null)
        {
            attributeCreation = GenerateCommandArgumentAttribute(
                semanticModel,
                argAttr,
                typeForTypeof
            );
        }
        else
        {
            // If no attribute found, use CommandArgumentUnknownAttribute as fallback
            attributeCreation = $"new CommandArgumentUnknownAttribute(typeof({typeForTypeof}))";
        }

        sb.AppendLine($"                new CommandArgumentInfo(");
        sb.AppendLine($"                    {attributeCreation},");
        sb.AppendLine($"                    typeof({typeForTypeof}),");
        sb.AppendLine($"                    {isOptional},");
        sb.AppendLine($"                    {defaultValue}");
        sb.AppendLine($"                ),");
    }

    private static string GenerateCommandArgumentAttribute(
        SemanticModel semanticModel,
        AttributeSyntax attribute,
        string typeForTypeof
    )
    {
        switch (semanticModel.GetTypeInfo(attribute).Type?.Name)
        {
            // Handle CommandArgumentString
            case "CommandArgumentStringAttribute":
            {
                var description = GetAttributeArgument(attribute, 0) ?? "\"\"";
                return $"new CommandArgumentStringAttribute({description})";
            }
            // Handle CommandArgumentStringMatch
            case "CommandArgumentStringMatchAttribute":
            {
                var pattern = GetAttributeArgument(attribute, 0) ?? "\".*\"";
                var options = GetAttributeArgument(attribute, 1) ?? "RegexOptions.None";
                var description = GetAttributeArgument(attribute, 2) ?? "\"\"";
                return $"new CommandArgumentStringMatchAttribute({pattern}, {options}, {description})";
            }
            // Handle CommandArgumentEnum
            case "CommandArgumentEnumAttribute":
            case { } name when name.Contains("CommandArgumentEnum"):
            {
                var description = GetAttributeArgument(attribute, 0) ?? "\"\"";
                // For generic enum attributes, we need to preserve the type parameter
                if (attribute.Name is GenericNameSyntax genericName)
                {
                    var typeArg = genericName.TypeArgumentList.Arguments.FirstOrDefault();
                    var typeArgStr = GetFullTypeName(typeArg, semanticModel, typeForTypeof);
                    return $"new CommandArgumentEnumAttribute<{typeArgStr}>({description})";
                }

                return $"new CommandArgumentEnumAttribute<{typeForTypeof}>({description})";
            }
            // Fallback to CommandArgumentUnknownAttribute
            default:
                return $"new CommandArgumentUnknownAttribute(typeof({typeForTypeof}))";
        }
    }

    private static string? GetAttributeArgument(AttributeSyntax attribute, int index)
    {
        if (attribute.ArgumentList?.Arguments.Count > index)
        {
            var arg = attribute.ArgumentList.Arguments[index];
            return arg.Expression.ToString();
        }
        return null;
    }

    private static bool IsCommandArgumentAttribute(
        SemanticModel semanticModel,
        AttributeSyntax attribute
    )
    {
        var commandArgumentAttribute = semanticModel.Compilation.GetTypeByMetadataName(
            CommandArgumentAttributeBaseFullName
        )!;
        var attributeTypeInfo = semanticModel.GetTypeInfo(attribute).Type as INamedTypeSymbol;
        return attributeTypeInfo is not null
            && Helper.ContainsBaseType(attributeTypeInfo, commandArgumentAttribute);
        ////get all derived types of CommandArgumentAttribute
        //var commandArgumentAttributeDerivedTypes = Helper
        //    .FilterTypesInNamespace(semanticModel, "HuaJiBot.NET.Commands")
        //    .Where(t => Helper.ContainsBaseType(t, commandArgumentAttribute));
        //foreach (var commands in commandArgumentAttributeDerivedTypes)
        //{
        //    if (commands.Equals(attributeTypeInfo, SymbolEqualityComparer.Default))
        //    {
        //        return true;
        //    }
        //}
        //return false;

        //var name = attribute.Name.ToString();
        //return name.Contains("CommandArgument") && !name.Contains("CommandArgumentUnknown");
    }

    private static string GetStringLiteralValue(ExpressionSyntax expression)
    {
        if (
            expression is LiteralExpressionSyntax literal
            && literal.Token.IsKind(SyntaxKind.StringLiteralToken)
        )
        {
            return literal.Token.ValueText;
        }
        return expression.ToString().Trim('"');
    }

    private static bool IsCommandAttribute(AttributeSyntax attribute, SemanticModel semanticModel)
    {
        var typeName = semanticModel.GetTypeInfo(attribute).Type?.ToDisplayString();
        return typeName == CommandAttributeFullName;
    }

    private static string GetNamespace(ClassDeclarationSyntax classDecl)
    {
        var namespaceDecl = classDecl
            .Ancestors()
            .OfType<NamespaceDeclarationSyntax>()
            .FirstOrDefault();
        if (namespaceDecl != null)
        {
            return namespaceDecl.Name.ToString();
        }

        var fileScopedNamespace = classDecl
            .Ancestors()
            .OfType<FileScopedNamespaceDeclarationSyntax>()
            .FirstOrDefault();
        if (fileScopedNamespace != null)
        {
            return fileScopedNamespace.Name.ToString();
        }

        return string.Empty;
    }
}
