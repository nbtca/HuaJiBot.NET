using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace HuaJiBot.NET.SourceGenerator;

[Generator]
public class PluginConfigSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all classes that implement IPluginWithConfig<T>
        var pluginClasses = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => s is ClassDeclarationSyntax { BaseList: not null } cls &&
                                            cls.BaseList.Types.Any(t => t.ToString().Contains("IPluginWithConfig")),
                transform: static (ctx, _) => GetPluginClassWithConfig(ctx))
            .Where(static m => m != null);

        // Generate code for each plugin class
        context.RegisterSourceOutput(pluginClasses, static (spc, source) => Execute(source!, spc));
    }

    private static ClassDeclarationSyntax? GetPluginClassWithConfig(GeneratorSyntaxContext context)
    {
        var classDecl = (ClassDeclarationSyntax)context.Node;
        
        // Check if this class implements IPluginWithConfig<T>
        if (classDecl.BaseList?.Types.Any(t => t.ToString().Contains("IPluginWithConfig")) == true)
        {
            return classDecl;
        }
        
        return null;
    }

    private static void Execute(ClassDeclarationSyntax classDecl, SourceProductionContext context)
    {
        var className = classDecl.Identifier.ValueText;
        var namespaceName = GetNamespace(classDecl);

        // Find the IPluginWithConfig<T> implementation
        var configInterface = classDecl.BaseList?.Types
            .FirstOrDefault(t => t.ToString().Contains("IPluginWithConfig"));
        
        if (configInterface == null) return;

        // Extract the config type T from IPluginWithConfig<T>
        var configType = ExtractConfigType(configInterface.ToString());
        if (string.IsNullOrEmpty(configType)) return;

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("using System;");
        sb.AppendLine("using HuaJiBot.NET;");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(namespaceName) && namespaceName != "<global namespace>")
        {
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine("{");
        }

        sb.AppendLine($"    partial class {className}");
        sb.AppendLine("    {");
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Generated fast config access - replaces reflection");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        internal static bool TryGetPluginConfigFast(object plugin, out ConfigBase? config)");
        sb.AppendLine("        {");
        sb.AppendLine($"            if (plugin is {className} typedPlugin)");
        sb.AppendLine("            {");
        sb.AppendLine("                config = typedPlugin.Config;");
        sb.AppendLine("                return config != null;");
        sb.AppendLine("            }");
        sb.AppendLine("            config = null;");
        sb.AppendLine("            return false;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");

        if (!string.IsNullOrEmpty(namespaceName) && namespaceName != "<global namespace>")
        {
            sb.AppendLine("}");
        }

        var fileName = $"{className}_ConfigAccess.g.cs";
        context.AddSource(fileName, SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static string ExtractConfigType(string interfaceString)
    {
        // Simple extraction of T from IPluginWithConfig<T>
        var start = interfaceString.IndexOf('<');
        var end = interfaceString.LastIndexOf('>');
        if (start >= 0 && end > start)
        {
            return interfaceString.Substring(start + 1, end - start - 1).Trim();
        }
        return string.Empty;
    }

    private static string GetNamespace(ClassDeclarationSyntax classDecl)
    {
        var namespaceDecl = classDecl.Ancestors().OfType<NamespaceDeclarationSyntax>().FirstOrDefault();
        if (namespaceDecl != null)
        {
            return namespaceDecl.Name.ToString();
        }

        var fileScopedNamespace = classDecl.Ancestors().OfType<FileScopedNamespaceDeclarationSyntax>().FirstOrDefault();
        if (fileScopedNamespace != null)
        {
            return fileScopedNamespace.Name.ToString();
        }

        return string.Empty;
    }
}